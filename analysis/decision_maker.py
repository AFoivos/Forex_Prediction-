import numpy as np
import pandas as pd
from typing import Dict, Any
import textwrap

##### PRINTS GENERATED BY AI (GitHub Copilot) #####

class ForexTimeSeriesDecisionMaker:
    def __init__(
        self, 
        analysis_results: Dict[str, Any]
    ):
        
        print("="*50)
        print("TIME SERIES DECISION MAKER")
        print("="*50)
        print(" Available Functions \n1 analyze_stationarity \n2 analyze_volatility \n3 analyze_distribution \n4 analyze_seasonality \n5 print_comprehensive_report")
        print("="*50)
        
        self.results = analysis_results
        self.decisions = {}
        
    def analyze_stationarity(
        self
    ):
        
        """
        Stationarity Distribution
        
        """
        
        stats = self.results['stationarity_tests']
        
        decisions = {}
        
        returns_stationary = (
            stats['Returns']['adf_stationary'] and 
            stats['Returns']['kpss_stationary']
        )
        
        if returns_stationary:
            decisions['returns_analysis'] = "STATIONARY - Suitable for modeling"
            decisions['use_returns'] = True
        else:
            decisions['returns_analysis'] = "NON-STATIONARY - Needs transformation"
            decisions['use_returns'] = False
            
        price_stationary = (
            stats['Price']['adf_stationary'] or 
            stats['Price']['kpss_stationary']
        )
        decisions['price_analysis'] = "Use for level analysis only"
        
        self.decisions['stationarity'] = decisions
        
        return self.decisions
    
    def analyze_volatility(
        self
    ):
        
        """
        Volatility Distribution
        
        """
        
        vol_stats = self.results['volatility_analysis']
        acf_stats = self.results['autocorrelation_analysis']
        decisions = {}
        
        sq_returns_sig = any(p < 0.05 for p in acf_stats['squared_returns_lb']['lb_pvalue'])
        
        if sq_returns_sig:
            decisions['volatility_clustering'] = "PRESENT - ARCH/GARCH effects detected"
            decisions['volatility_model'] = "GARCH-family recommended"
        else:
            decisions['volatility_clustering'] = "ABSENT - Constant variance"
            decisions['volatility_model'] = "Standard models sufficient"
            
        if vol_stats['volatility_persistence'] > 0.9:
            decisions['persistence'] = "HIGH - Volatility shocks persist"
        else:
            decisions['persistence'] = "MODERATE - Mean-reverting volatility"
            
        avg_vol = vol_stats['avg_volatility']
        if avg_vol > 0.002:
            decisions['risk_level'] = "HIGH"
        elif avg_vol > 0.001:
            decisions['risk_level'] = "MODERATE" 
        else:
            decisions['risk_level'] = "LOW"
            
        self.decisions['volatility'] = decisions
        
        return self.decisions
    
    def analyze_distribution(
        self
    ):
        
        """
        Distribution Decisions
        
        """
        
        dist_stats = self.results['distribution_analysis']
        desc_stats = self.results['descriptive_stats']['Returns']
        decisions = {}
        
        jb_sig = dist_stats['jarque_bera_pval'] < 0.05
        shapiro_sig = dist_stats['shapiro_pval'] < 0.05
        
        if jb_sig or shapiro_sig:
            decisions['normality'] = "REJECTED - Non-normal distribution"
        else:
            decisions['normality'] = "NOT REJECTED - Approximately normal"
            
        skewness = desc_stats['skewness']
        if abs(skewness) > 1:
            decisions['skewness'] = "HIGH - Significant asymmetry"
        elif abs(skewness) > 0.5:
            decisions['skewness'] = "MODERATE - Mild asymmetry" 
        else:
            decisions['skewness'] = "LOW - Approximately symmetric"
            
        excess_kurtosis = dist_stats['excess_kurtosis']
        if excess_kurtosis > 3:
            decisions['tails'] = "HEAVY - Extreme values likely"
        elif excess_kurtosis > 1:
            decisions['tails'] = "MODERATE - Some tail risk"
        else:
            decisions['tails'] = "LIGHT - Normal tails"
            
        extreme_pct = dist_stats['extreme_returns_pct']
        if extreme_pct > 5:
            decisions['extremes'] = "HIGH - Many outliers"
        elif extreme_pct > 2:
            decisions['extremes'] = "MODERATE - Some outliers"
        else:
            decisions['extremes'] = "LOW - Few outliers"
            
        self.decisions['distribution'] = decisions
        
        return self.decisions
    
    def analyze_seasonality(
        self
    ):
        
        """
        Seasonality Distribution
        
        """
       
        seasonal_stats = self.results['seasonal_decomposition']
        decisions = {}
        
        seasonal_strength = seasonal_stats['seasonal_strength']
        trend_strength = seasonal_stats['trend_strength']
        
        if seasonal_strength > 0.6:
            decisions['seasonality'] = "VERY STRONG - Dominant seasonal patterns"
            decisions['seasonal_model'] = "Must use seasonal models (SARIMA, Prophet)"
        elif seasonal_strength > 0.3:
            decisions['seasonality'] = "STRONG - Clear seasonal patterns" 
            decisions['seasonal_model'] = "Seasonal models recommended"
        elif seasonal_strength > 0.1:
            decisions['seasonality'] = "WEAK - Mild seasonal patterns"
            decisions['seasonal_model'] = "Optional seasonal components"
        else:
            decisions['seasonality'] = "NEGLIGIBLE - No significant seasonality"
            decisions['seasonal_model'] = "Non-seasonal models sufficient"
            
        if trend_strength > 0.3:
            decisions['trend'] = "STRONG - Clear trend component"
        elif trend_strength > 0.1:
            decisions['trend'] = "WEAK - Mild trend"
        else:
            decisions['trend'] = "NEGLIGIBLE - No clear trend"
            
        self.decisions['seasonality'] = decisions 
        
        return self.decisions
    
    def print_comprehensive_report(
        self
    ):
        
        """
        Run a Comprehesive Report for Decisions 
        
        """
        
        print("=" * 50)
        print("TIME SERIES ANALYSIS - AUTOMATED DECISION REPORT")
        print("=" * 50)
        
        self.analyze_stationarity()
        self.analyze_volatility() 
        self.analyze_distribution()
        self.analyze_seasonality()
        
        print("\n STATIONARITY ANALYSIS")
        print("-" * 50)
        for key, value in self.decisions['stationarity'].items():
            print(f"{key:20}: {value}")
            
        print("\n VOLATILITY ANALYSIS")
        print("-" * 50)
        for key, value in self.decisions['volatility'].items():
            print(f"{key:20}: {value}")
            
        print("\n DISTRIBUTION ANALYSIS") 
        print("-" * 50)
        for key, value in self.decisions['distribution'].items():
            print(f"{key:20}: {value}")
            
        print("\n SEASONALITY ANALYSIS")
        print("-" * 50) 
        for key, value in self.decisions['seasonality'].items():
            print(f"  {key:20}: {value}")

        print("\n KEY METRICS SUMMARY")
        print("-" * 50)
        vol_stats = self.results['volatility_analysis']
        dist_stats = self.results['distribution_analysis']
        
        print(f"Avg Volatility: {vol_stats['avg_volatility']:.4f}")
        print(f"Vol of Vol: {vol_stats['vol_of_vol']:.4f}")
        print(f"Max Drawdown: {self.results['drawdown_analysis']['max_drawdown']:.4f}")
        print(f"Skewness: {dist_stats['skewness']:.4f}")
        print(f"Kurtosis: {dist_stats['kurtosis']:.4f}")
        print(f"Extreme Returns: {dist_stats['extreme_returns_pct']:.4f}%")
        
        print("=" * 50)
